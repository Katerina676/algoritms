# --- ПРИНЦИП РАБОТЫ ---
# Задача делится на две подзадачи, сначала мы распаковываем строки потом ищем наибольший общий префикс(Longest(or
# Largest)common prefix)(LCP).Распаковка происходит через стек, проходимся по всем символам строки, закидываем их в
# стек, находим ] и начинаем разворачивать стэк до [, в список собираем символы между скобок, вынимаем число повторений
# умножаем на список символов, и возвращаем в виде строки.
# Поиск общего префикса: посимвольно сравниваем каждый символ строки с другим символом на этой позиции.
# возьмём самую маленькую строчку из всех и пройдёмся по каждому её символу, каждый символ будем сверять с символами
# на тех же местах у других строк, как только мы найдём хотя бы одно расхождение, мы найдём индекс конца префикса.
# --- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ ---
# Ясно что общие символы не могут быть больше длины самой короткой строки из всех заданных строк, поэтому сначало
# мы находим самую короткую строку среди строк и проверим присутствует ли максимальное количество символов во всех
# остальных строках.Самую короткую троку и ее длину, потом мы берем первую строку и сопоставим каждый ее символ один
# за другим со всеми остальными строками, как только мы столкнемся с расхождением мы выйдем их цикла.
# --- ВРЕМЕННАЯ СЛОЖНОСТЬ ---
# Если длина массива n и длина короткой строки m то в худшем случае сложность равна O(m * n)
# Функция распаковки работает за O(N^2) в худшем случае, например если скобки стоят с краю, то сначала
# все элементы добавятся в стэк, а потом в обратном проходе уберутся.O(n) в лучшем и среднем.
# --- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ ---
# На хранение префикса мы не используем доп память - O(1)
# Из памати функция использует стэк, который занимает O(n) места.
# id 65115185

def unpack(string):
    stack = []
    for char in string:
        stack.append(char)
        if char == ']':
            result = []
            while stack.pop() != '[':
                if stack[-1] != '[':
                    result.insert(0, stack[-1])
            repeat = int(stack.pop())
            stack += repeat * result
    return ''.join(stack)


def max_prefix(strings):
    if len(strings) == 1:
        return strings[0]
    min_len = strings.index(min(strings, key=len))
    # тоже рабочие ID 65115208
    # min_len = list(map(len, strings))
    # min_len = min_len.index(min(min_len))
    # min_len = min(map(len, strings))

    for i in range(len(strings[min_len])):
        curr = strings[0][i]
        for j in strings[1:]:
            if curr != j[i]:
                return j[:i]
    return strings[min_len]


if __name__ == '__main__':
    n = int(input())
    strings = list()

    for i in range(n):
        strings.append(unpack(input()))
    print(max_prefix(strings))



