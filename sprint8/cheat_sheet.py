# --- ПРИНЦИП РАБОТЫ ---
# Собираем слова в стуктуру данных бор(trie). создаем массив valid - проверочный массив узлов, в котором
# терминальный (выходной) узел - True, а нетерминальный узел - false.
# базовый случай: valid[0] = true, пустой текст можно набрать, если не брать ни одно слово из словаря.
# То есть если в trie есть такая последовательность узлов, что некоторая последовательность символов в слове равна
# первой, то в массиве valid значение True будет расположено там, где заканчивается подслово в слове.Начинаем с корня
# бора начинаем перебирать символы наблона начиная со стартовой позиции, в цикле двигаемся по следующим узлам,
# Если это терминальный узел и я могу в него попасть из предыдущей позиции, то отмечаем позицию, как достижимую,
# поскольку нужно добраться до конца строки - смотрим на последний элемент.
# --- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ ---
# Идея решения была взята из теории к спринту про префиксное дерево.
# Префиксное дерево, построенное из множества слов-шаблонов {p_i}
# поможет быстро проверить, входит ли некоторая строка ss в это множество или нет.
# Мы будем перебирать по очереди все символы строки s, начиная с корня и спускаясь по бору вниз:
# 1.Если какого-то из переходов не нашлось, значит, строки ss в боре нет. Для нашей задачи это означает, что слово s
# не встречается в словаре и не является префиксом никакого из слов. Поэтому дополнить это слово невозможно.
# 2. Если переходы по каждому из символов нашлись, то в конце нужно проверить, является ли узел терминальным.
# (а) Если да, значит, искомая строка принадлежит множеству: s принадлежит {p_i} и является словарным словом.
# (б) Если нет, то искомая подстрока — префикс одной или более строк данного множества.В обоих случаях возможно
# предложить варианты автодополнения. Для этого следует найти все терминальные узлы, являющиеся потомками узла,
# на котором остановился алгоритм.
# Получается мы методом динакими идем по массиву расставляя True там где кончается наше слово и смотрим все комбинации.
#  Так идем до конца динамики, и если в конце в последней ячейке будет лежать True,
#  то рассматриваемую строку можно составить из искомых слов.
# --- ВРЕМЕННАЯ СЛОЖНОСТЬ ---
# Функция построения префиксного дерева работает за O(L), где L — суммарная длина слов во множестве.
# Функция нахождения слов работает за O(N * M), где N — длина текста, M = max(Mi) - длина самого длинного
# из искомых слов.Итоговая временная сложность составляет: T * O(L) + O(N * M), где T - кол-во допустимых слов.
# --- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ ---
# Память для хранения префиксного дерева составляет O(L), где L — суммарная длина слов во множестве,
# такое возможно, если у всех слов разные префиксы, т.е. худший случай.Еще массив терминальных элементов O(K),
# где K - кол-во элементов в боре.И массив достижимости O(n).
# id 65110757


def add_string(trie, terminals, string):
    current_node = trie[0]
    current_node_index = 0

    for char in string:
        if char not in current_node:
            current_node[char] = len(trie)
            trie.append({})
            terminals.append(False)

        next_node_index = current_node[char]
        current_node = trie[next_node_index]
        current_node_index = next_node_index

    terminals[current_node_index] = True


def find_any(trie, terminals, string):
    valid = [True] + [False] * (len(string))

    for pos in range(0, (len(string))):
        if not valid[pos]:
            continue
        current_node = trie[0]
        offset = 0
        while pos + offset < len(string):
            symbol = string[pos + offset]
            if symbol not in current_node:
                break
            next_index = current_node[symbol]
            current_node = trie[next_index]
            if terminals[next_index]:
                valid[pos + offset + 1] = True
            offset += 1

    return valid[len(string)]


if __name__ == "__main__":
    trie = [{}]
    terminals = [False]

    string = input()
    n = int(input())

    for _ in range(n):
        dict_word = input()
        add_string(trie, terminals, dict_word)

    is_valid = find_any(trie, terminals, string)

    print("YES" if is_valid else "NO")

