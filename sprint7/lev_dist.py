# --- ПРИНЦИП РАБОТЫ ---
# Метод динамического программирования где мы вычисляем расстояние редактирования между подстроками первой и второй
# строки,пока не найдем расстояние редактирования между целыми строками.Реализован алгоритм Вагнера-Фишера.
# Для хранения данных используем двумерный
# матрица [i][j], где в строке и столбце хранятся исходные строки.Там хранятся редакционные расстояния,то есть
# сколько символов надо изменить чтобы получить из 1 строку 2.Каждая итерация внешнего цикла обозначает
# увеличения префикса первой строки на 1 символ, каждая итерация вложенного цикла - увеличение префикса второй строки на
# 1 символ.Так как ответ будет содержаться в правой нижней клетке,то хранить все ряды матрицы это трата памяти,поэтому
# мы храним только предыдущий и текущий ряды.Сначала, чтобы использовать еще меньше памяти, мы можем поменять местами
# наши строки, чтобы длина рядов была минимальна. Это существенно экономит память, если одна из строк длинная, а другая
# короткая.И мы понимаем что матрица это всего лишь восходящая последовательность потому что, чтобы из пустой строки
# получить любую не пустую, нужно ровно то число вставок, сколько символов в не пустой строке. И наоборот: n
# удалений из строки длины n приведут неизбежно к пустой строке.И мы итерируемся по рядам матрицы помня только
# предыдущий и текущий и заполняем неизвестные клетки текущего ряда.И выбираем их трех изменений то чья стоимость
# наименьшая.Мы считаем разницу сравнивая текущие символы двух строк, если они не равны ставим 1
# или предыдущее расстояние + 1, если равны 0 или предыдущее вычисленное расстояние.
# --- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ ---
# Очевидно, что редакционное расстояние между двумя пустыми строками равно нулю. Так же очевидно то, что чтобы
# получить пустую строку из строки длиной i, нужно совершить i операций удаления, а чтобы получить строку длиной
# j из пустой, нужно произвести j операций вставки.Когда обе строки не пусты.
# Пусть S1-первая строка кончается на "a", вторая строка S2- кончается на "b" есть разные варианты:
# 1. Символ а на который кончается 1 строка в какой то момент был стерт,это стирание будет первая операция.Тогда мы
# стёрли символ «a», после чего превратили первые i-1 символов S1 в S2 (на что потребовалось D(i-1, j) операций),
# значит, всего потребовалось D(i-1, j)+1 операций.
# 2. Символ строки S2 - b был в какой то момент добавлен.Допустим это добавление последняя операция, мы превратили
# S1 в первые j-1 символов S2, после чего добавили b. Аналогично предыдущему случаю, потребовалось
#  D(i, j-1)+1 операций.
# 3.Оба предыдущие утверждения не верны. Если мы добавляли символы справа от финального «a», то, чтобы сделать
# последним символом b, мы должны были или в какой-то момент добавить его (но тогда утверждение 2 было бы верно),
# либо заменить на него один из этих добавленных символов (что тоже невозможно, потому что добавление символа с его
# последующей заменой неоптимально). Значит, символов справа от финального a мы не добавляли. Самого финального «a»
# мы не стирали, поскольку утверждение 1 неверно. Значит, единственный способ изменения последнего символа — его
# замена. Заменять его 2 или больше раз неоптимально. Значит:
# 1)Если a=b, мы последний символ не меняли. Поскольку мы его также не стирали и не приписывали ничего справа от него,
# он не влиял на наши действия, и, значит, мы выполнили D(i-1, j-1) операций.
# 2) Если a != b, мы последний символ меняли один раз. Сделаем эту замену первой.
# В дальнейшем, аналогично предыдущему случаю, мы должны выполнить  D(i-1, j-1)операций, значит,
# всего потребуется D(i-1, j-1)+1 операций.
# --- ВРЕМЕННАЯ СЛОЖНОСТЬ ---
# Сложность составляет O(N*M) где N - длина первой строки и M - длинна второй, тк каждый символ первой строки
# проверяется с символом второй.
# --- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ ---
# Сложность O(N), тк мы храним данные в двух строках.
# id 64985845


def distance():
    a = list(input().strip())
    b = list(input().strip())
    n, m = len(a), len(b)

    if m == 0 or n == 0:
        return max(n, m)

    current_row = range(n + 1)
    for i in range(1, m + 1):
        previous_row, current_row = current_row, [i] + [0] * n
        for j in range(1, n + 1):
            add = previous_row[j] + 1
            delete = current_row[j - 1] + 1
            change = previous_row[j - 1] + int(a[j - 1] != b[i - 1])
            current_row[j] = min(add, delete, change)

    return current_row[n]


if __name__ == "__main__":
    print(distance())
