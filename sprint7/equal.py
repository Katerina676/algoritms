# --- ПРИНЦИП РАБОТЫ ---
# Используется алгоритм динамического программирования, в котором мы сначала вычисляем четна ли наша сумма всех
# элементов,если да то значит можно разбить наши числа на подмножества с равными суммами.Далее мы будем
# перебирать по очереди элементы чтобы отмечать все возможные результаты,которые мы можем получить пользуясь данным
# элементом и предыдущим.Если одна из комбинаций даст нам половину от суммы всех элементов ,значит такие два
# подмножества существуют и нет в противном случае.В массиве dp хранится логический тип данных, который говорит нам
# равна ли текущая полусумма i - score(иследуемый элемент) сумме уже иследованных элементов.
# Базовый случай это когда проверяется пустое подмножество из входного массива
# будет False в каждой ячейке dp. В каждую клетку переход динамики i - score. Формула перехода: значение в текущей
# ячейки True, если: верно значение в любой ячейке с индексом i - score и False в противном случае.
# --- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ ---
# Представим вход алгоритма как список вида: S = x1...,...,xn, пусть N количество элементов, K  сумма всех элементов
# Мы хотим определить, существует ли подмножество S, сумма элементов которого равна  K/2. Пусть p(i,j) принимает True
# если среди {x1...xj} есть такое подмножество элементы которых дадут в сумме i и False в противном случае.Тогда
# p(K/2, n) принимает значение True тогда и только тогда, когда существует подмножество S, сумма которого равна K/2.
# Наша цель алгоритма — вычислить p(K/2, n). Для достижения этого мы имеем следующие рекуррентные формулы:
# p(i, j) принимает значение True, если либо p(i, j − 1) принимает значение True, либо p(i − xj, j − 1) принимает
# значение True
# p(i, j) принимает значение False в противном случае
# Причина этому следующая: существует некоторое подмножество S, сумма которого равна i для чисел x1, ..., xj
# тогда и только тогда, когда одно из двух верно: существует подмножество { x1, ..., xj-1 }, дающее сумму i;
# существует подмножество { x1, ..., xj-1 }, дающее сумму i − xj, поскольку xj + сумма этого подмножества=i.
# --- ВРЕМЕННАЯ СЛОЖНОСТЬ ---
# Этот алгоритм работает за время O(K * N),
# где N — число элементов во входном множестве, а K — сумма элементов во входном множестве.
# --- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ ---
# Пространственная сложность состоит из хранения массива размером K / 2 + 1,что равносильно O(K).
# id 65044641


def equal_sum(scores):
    sum_scores = sum(scores)

    if sum_scores % 2 != 0:
        return False
    else:
        mid = sum_scores // 2
        dp = [False] * (mid + 1)
        dp[0] = True
        for score in scores:
            for i in range(mid, score - 1, -1):
                if dp[i - score] != dp[i]:
                    dp[i] = True
        return dp[mid]


if __name__ == '__main__':
    _ = int(input())
    scores = [int(x) for x in input().split()]
    print(equal_sum(scores))
