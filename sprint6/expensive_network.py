# --- ПРИНЦИП РАБОТЫ ---
# Реализация алгоритма Прима на очереди с приоритетами.Мы храним ребра исходящие из уже собранного подмножества остова
# в куче с поддержанием максимума.
# --- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ ---
# Создаем множество для хранения добавленных вершин в остов- added и не добавленных в остов not_added - словарь
# и массив ребер исходящих из остовного дерева.Посещенные вершины мы добавляем в множество , а ребра которые мы можем
# посетить мы будем хранить в куче.Если вместе с ребром в подграф добавляется новая вершина, то это ребро добавляется в
# остов. Если ребро соединяет две вершины, уже присутствующее в подмножестве остова, мы отбрасываем его из дальнейшего
# рассмотрения и из кучи в том числе.Обход графа начинается с первой вершины.Пока добавленные и не добавленные множества
# не пусты. Мы будем доставать из кучи самые большие ребра, до тех пор пока конечная вершина ребра не будет в множестве
# посещённых вершин или рёбра не закончатся. Прибавим вес найденного ребра к нашему ответу и повторим все действия для
# конечной вершины.Таким образом сформируется максимальное остовное дерево.Для кучи мы используем встроенную реализацию
# heapq, а для того чтобы сортировалось по максимуму используем знак минус для весов.
# --- ВРЕМЕННАЯ СЛОЖНОСТЬ ---
# Сложность алгоритма O(E*logV), где V-количество вершин и E-количество ребер, так как мы используем алгоритм прима с
# приоритетной очередью.
# --- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ ---
# Алгоритм занимает O(V + E), где V-количество вершин и E-количество ребер

# id 64711197

from heapq import heappush, heappop


def add_vertex(added, v, not_added, graph, edges):
    added.add(v)
    not_added.remove(v)
    for i in graph[v]:
        if i in not_added:
            heappush(edges, [-graph[v][i], v, i])


def find_mst(graph):
    added = set()
    not_added = {i for i in range(1, len(graph) + 1)}
    edges = []
    mst = 0
    v = list(graph.keys())[0]
    add_vertex(added, v, not_added, graph, edges)
    while not_added and edges:
        e = heappop(edges)
        if e[2] in not_added:
            mst += -e[0]
            add_vertex(added, e[2], not_added, graph, edges)

    if not_added:
        return 'Oops! I did it again'
    else:
        return mst


def main():
    n, m = map(int, input().strip().split())
    graph = {(n + 1): {} for n in range(n)}
    for _ in range(m):
        v, u, w = map(int, input().strip().split())
        if graph.get(u).get(v) is None or graph[u].get(v) < w:
            graph[v][u] = w
            graph[u][v] = w

    if n > 1 and m == 0:
        print('Oops! I did it again')
    else:
        mst = find_mst(graph)
        print(mst)


if __name__ == '__main__':
    main()
