# --- ПРИНЦИП РАБОТЫ ---
# Входные данные мы сохраняем в списках смежности,только одно ребро мы переворачиваем чтобы получился ориентированный
# граф и если в таком графе мы натыкаемся на серую вершину при поиске в глубину, мы находим цикл,что говорит о том
# что с этой вершины мы начали свой путь и в нее вернулись по другой дороге.
# --- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ ---
# По условию задачи нам надо понять оптимальна ли дорога,в оптимальном маршруте нет таких городов по которым можно
# пройти по дороге одного типа и другого типа.
# Есть основания полагать что наш граф это граф Турнир - ориентированный граф,полученный из неориентированного полного
# графа путем назначения направления каждому ребру.Т.е это орграф в котором каждая пара соединена одной направленной
# дугой.
# Теорема гласит, что любой сильно связный граф-турнир гамильтонов.
# Доказательсво что есть цикл длинны 3: (метод матиматической индукции по длине цикла),
# Пусть наш граф T сильно связный турнир,тогда для любой вершины v из Т все множества дуг ей инцидентных можно разделить
# на два непересекающихся подмножества W-множество для которых v является концом и Z-множество для которых v-является
# началом.Т.к T сильно связен, то эти оба множества не пусты, следовательно найдутся вершины w принадлежащая W и z
# принадлежащая Z, тогда имеем цикл v,w,z,v длинны три.
# То есть цикл будет равен 3 или больше:
# ( Любой турнир с конечным числом n вершин,содержит гамильтонов путь, то есть ориентированный путь,содержащий все n
# вершин.При помощи мат.индукции видно что турнир T с n+1 вершинами, выбираем вершину v0 и пусть v1, v2....vn
# направленный путь в T \ {v0}, Пусть i принадлежит {0....n}-максимальное число такое что для любого j <= i имеется
# дуга из vj в v0.Тогда v1..,...,vi,v0,vi+1,...vn искомый ориентированный путь)
# Далее докажем если в графе нет цикла:
# турнир в котором (a, b) ^ (b, c) => (a, c), является транзитивным,где все величины упорядочены в порядке достижимости.
# Транзитивности эквивалента ацикличность.
# Пусть существует цикл длинны 3: (u, v), (u, w), (w, u).Однако по транзитивности должно существовать ребро(u,w) т.е
# между u, w есть два противоположнонаправленных ребра,что невозможно по определению турнира.
# Пусть в графе есть цикл != 3. Это не может быть цикл длинны k = 2(по определению турнира), обозначаем его вершины по
# порядку обхода, v1, v2, ..., vk, k >= 4 , тк нет циклов длинны 3, выполнена транзитивность,в противном случае
# существовали бы ребра, (u,v)(v,w),(w,v).Докажем по индукции,что существует ребро (v1,vk-1).База индукции k=3
# (v1,v2)(v2,v3) принадлежит E => (v1,v3) принадлежит E(по транзитивности).Переход индукции - пусть доказано для всех
# i < k-1, что (v1,vi)принадлежит E, также известно, что (vi,vi+1) принадлежит E, тогда по тразитивности(v1,vi+1)
# принадлежит E.Таким образом в транзитивном турнире содержится цикл длинны 3-противоречение,доказанное выше.
# Итог - в нашем графе если есть цикл, значит путь неоптимльный, тк существует два разных пути между вершинами R и B.
# и поэтому если существует цикл то длинны от 3.
# --- ВРЕМЕННАЯ СЛОЖНОСТЬ ---
# Сложность алгоритма DFS O(V + E), где V-кол-во вершин и E-кол-во ребер.
# --- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ ---
# Список смежности - O(E * V), где E - количество вершин, V - количество рёбер
# id 64808032


WHITE = 0
GRAY = 1
BLACK = 2


class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def size(self):
        return len(self.items)


def dfs(start, graph, colors):
    # создаем стек и кладем туда первую вершину
    stack = Stack()
    stack.push(start)
    # пока стек не пуст мы проверяем вершину и всех ее потомков
    while stack.size() > 0:
        v = stack.pop()
        if colors[v] == WHITE:
            colors[v] = GRAY
            stack.push(v)
            for i in graph[v]:
                if colors[i] == GRAY:
                    # для двух городов нашлись две дороги разного типа
                    return True
                if colors[i] == WHITE:
                    stack.push(i)
        elif colors[v] == GRAY:
            colors[v] = BLACK
    return False


def find_cycle(graph, colors):
    # запускаем цикл для всей длинны вершин в графе,по очереди для каждой
    for i in range(0, len(graph)):
        if dfs(i, graph, colors):
            return True
    return False


def main():
    n = int(input().strip())
    adjacency_list = [[] for _ in range(n)]
    colors = [WHITE for n in range(n + 1)]
    for i in range(n - 1):
        for j, k in enumerate(input().strip(), start=1):
            # кладем в матрицу в прямом положении
            if k == 'B':
                adjacency_list[i].append(i + j)
            # переворачиваем ребро
            elif k == 'R':
                adjacency_list[i + j].append(i)
    if find_cycle(adjacency_list, colors):
        print('NO')
    else:
        print('YES')


if __name__ == '__main__':
    main()
